# k means clustering to generate video summary
import sys
import imageio
import numpy as np
import cv2
import scipy.io


def VSUMM(path_in, sample_rate, summ_percent, hist):

    global num_bins, sampling_rate, percent, num_centroids
    num_bins = 16

    # size of values in each bin
    range_per_bin = 256 / num_bins

    # frame chosen every k frames
    sampling_rate = sample_rate

    # number of centroids
    percent = summ_percent

    # globalizing
    num_centroids = 0


    print("Opening video!")
    video = imageio.get_reader(path_in)
    vidcap = cv2.VideoCapture(path_in)
    frame_count = vidcap.get(cv2.CAP_PROP_FRAME_COUNT)
    print("Video opened\nChoosing frames")
    print(len(video))
    print(frame_count)
    # choosing the subset of frames from which video summary will be generateed
    frames = [video.get_data(i * sampling_rate) for i in range(int(frame_count / sampling_rate))]
    print("Frames chosen")
    print("Length of video %d" % frame_count)

    # converting percentage to actual number
    num_centroids = int(percent * frame_count / 100)
    if (frame_count / sampling_rate) < num_centroids:
        print("Samples too less to generate such a large summary")
        print("Changing to maximum possible centroids")
        num_centroids = frame_count / sampling_rate

    if hist == 1:
        print("Generating 3D Tensor Histrograms")
        # manually generated histogram
        color_histogram = [generate_histogram(frame) for frame in frames]
        print("Color Histograms generated")

    # opencv: generates 3 histograms corresponding to each channel for each frame
    print("Generating linear Histrograms using OpenCV")
    channels = ['b', 'g', 'r']
    hist = []
    for frame in frames:
        feature_value = [cv2.calcHist([frame], [i], None, [num_bins], [0, 256]) for i, col in enumerate(channels)]
        hist.append(np.asarray(feature_value).flatten())
    hist = np.asarray(hist)
    print("Done generating!")
    print("Shape of histogram: " + str(hist.shape))

    # clustering: defaults to using the histogram generated by OpenCV
    print("Clustering")

    # choose number of centroids for clustering from user required frames (specified in GT folder for each video)
    if percent == -1:
        video_address = sys.argv[1].split('/')
        gt_file = video_address[len(video_address) - 1].split('.')[0] + '.mat'
        video_address[len(video_address) - 1] = gt_file
        video_address[len(video_address) - 2] = 'GT'
        gt_file = '/'.join(video_address)
        num_frames = int(scipy.io.loadmat(gt_file).get('user_score').shape[0])
        # automatic summary sizing: summary assumed to be 1/100 of original video
        num_centroids = int(0.1 * num_frames)

    kmeans = KMeans(n_clusters=num_centroids).fit(hist)
    print("Done Clustering!")

    print("Generating summary frames")
    summary_frames = []

    # transforms into cluster-distance space (n_cluster dimensional)
    hist_transform = kmeans.transform(hist)
    frame_indices = []
    for cluster in range(hist_transform.shape[1]):
        print("Frame number: %d" % (np.argmin(hist_transform.T[cluster]) * sampling_rate))
        frame_indices.append(np.argmin(hist_transform.T[cluster]))

    # frames generated in sequence from original video
    frame_indices = sorted(frame_indices)
    summary_frames = [frames[i] for i in frame_indices]
    print("Generated summary")

    out_array = save_keyframes(frame_indices, frame_count)
    return out_array

# manual function to generate a 3D tensor representing histogram
# extremely slow
def generate_histogram(frame):
    print("Received frame")
    global num_bins, sampling_rate, num_centroids
    histogram = np.zeros((num_bins, num_bins, num_bins))
    for row in range(len(frame)):
        for col in range(len(frame[row])):
            r, g, b = frame[row][col]
            histogram[int(r / num_bins)][int(g / num_bins)][int(b / num_bins)] += 1;
    return histogram
    print("Generated Histogram")


def save_keyframes(frame_indices, frame_count):
    global sampling_rate, num_centroids
    print("Saving frame indices")
    out_array = np.zeros(int(frame_count))
    for idx in frame_indices:
        out_array[idx] = 1;
    print("Saved indices")
    return out_array
